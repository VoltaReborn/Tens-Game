<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tens â€“ Card Game</title>
<style>
  #runTests.dev{ display:inline-block !important; }
  :root{ --felt:#0a5a3c; --felt-dark:#084a33; --gold:#f0c36a; --ivory:#f9f6ee; --ink:#1b1b1b; --accent:#e7b553; }
  html,body{height:100%}
  body{ margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; background: radial-gradient(1000px 600px at 50% 20%, var(--felt), var(--felt-dark)); color: var(--ivory); overflow-x:hidden; }
  .table{max-width: 1200px; margin: 0 auto; padding: 16px 16px 160px; position: relative;}
  h1{font-weight:800; letter-spacing:1px; margin:8px 0 0;}
  .sub{opacity:.85; margin:0 0 16px 0}
  .controls{display:flex; gap:12px; flex-wrap:wrap; align-items:center; margin:8px 0 16px 0;}
  select, button{background:#113f2d; color:var(--ivory); border:1px solid #205f45; border-radius:10px; padding:10px 12px; font-size:14px; box-shadow: inset 0 0 0 1px rgba(255,255,255,.05)}
  button.primary{background:linear-gradient(180deg,#facb76,#e7b553); color:#2d1c00; border-color:#e6b14c; font-weight:700}
  button:disabled{opacity:.5; cursor:not-allowed}
  .board{display:grid; grid-template-columns: 1fr 460px 1fr; gap:16px; align-items:start}
  .panel{background: rgba(0,0,0,.18); border:1px solid rgba(255,255,255,.15); border-radius:16px; padding:12px}
  .pile{background: rgba(0,0,0,.2); border:1px solid rgba(255,255,255,.15); border-radius:16px; padding:14px; min-height:140px; backdrop-filter: blur(4px)}
  .pile h3,.section h3{margin:0 0 8px 0; font-size:14px; opacity:.9}
  .stack{display:flex; flex-wrap:wrap; gap:6px}
  .card{width:48px; height:68px; border-radius:10px; display:flex; align-items:center; justify-content:center; font-weight:800; font-size:18px; position:relative; background:linear-gradient(180deg,#fff,#efefef); color:#111; border:1px solid #d8d8d8; box-shadow:0 1px 0 rgba(0,0,0,.3); transition: transform .15s ease, box-shadow .15s ease, opacity .2s ease; user-select:none}
  .card.red{color:#b02020}
  .card.faceDown{background:
    radial-gradient(circle at 50% 50%, rgba(255,255,255,.15) 0 7px, transparent 8px),
    repeating-linear-gradient(45deg, #1f5aa5, #1f5aa5 8px, #184b8a 8px, #184b8a 16px);
  color:transparent; border-color:#0e3a74; box-shadow:0 1px 0 rgba(0,0,0,.35), inset 0 0 0 2px rgba(255,255,255,.12)}
  .card.small{width:36px; height:52px; font-size:14px; border-radius:8px}
  .card.playable{outline:3px solid var(--accent); cursor:pointer; box-shadow:0 6px 20px rgba(0,0,0,.35)}
  .card.playable:hover{transform:translateY(-2px)}
  .lane{display:flex; flex-direction:column; gap:8px}
  .playerArea{background: rgba(0,0,0,.18); border:1px solid rgba(255,255,255,.15); border-radius:16px; padding:12px}
  .playerHeader{display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:8px}
  .badge{background: rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.18); padding:4px 8px; border-radius:999px; font-size:12px}
  .me .playerHeader{color: var(--accent)}
  .turnGlow{box-shadow:0 0 0 3px rgba(240,195,106,.4), 0 0 0 8px rgba(240,195,106,.18)}
  .log{max-height:160px; overflow:auto; font-size:13px; background: rgba(0,0,0,.2); border:1px solid rgba(255,255,255,.15); border-radius:12px; padding:10px}

  /* Collapsible scorebar */
  .scorebar{position:fixed; left:0; right:0; bottom:0; background: rgba(10,90,60,.92); border-top:1px solid rgba(255,255,255,.15); display:flex; gap:10px; padding:8px 10px; align-items:center; backdrop-filter: blur(6px)}
  .scorebar .scores{display:flex; gap:10px; font-size:12px; overflow-x:auto; white-space:nowrap; flex:1}
  .scorebar .slot{background: rgba(0,0,0,.18); border:1px solid rgba(255,255,255,.2); padding:4px 8px; border-radius:10px}
  #scoreToggle{ background: rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.2); border-radius:8px; padding:4px 8px; font-size:12px }
  .scorebar.collapsed #status{ display:none }

  .toast{position:fixed; top:16px; right:16px; background:#1a1a1a; color:#fff; padding:10px 12px; border-radius:10px; opacity:0; transform: translateY(-6px); transition: all .25s ease}
  .toast.show{opacity:1; transform: translateY(0)}
  /* Picker */
  .picker{position:fixed; left:50%; transform:translateX(-50%); bottom:68px; background:#103a2a; border:1px solid #1d5e45; border-radius:14px; padding:12px; display:none; gap:10px; align-items:center; box-shadow:0 8px 30px rgba(0,0,0,.35); z-index:1000; max-width:94vw; flex-wrap:wrap}
  .picker b{margin-right:8px}
  .picker button{background:#184b37}
  .picker .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .picker .choices{display:flex; gap:6px; flex-wrap:wrap; max-width:100%}
  @media (max-width: 900px){ .table{padding:12px 12px 200px} .board{grid-template-columns: 1fr; gap:12px} .controls{gap:8px} select,button{font-size:16px; padding:12px 14px; border-radius:12px} .panel,.pile{border-radius:14px} .playerHeader .badge{font-size:12px} .card{width:56px; height:80px; font-size:20px; border-radius:12px} .card.small{width:44px; height:64px; font-size:16px} .stack{gap:8px} .scorebar{padding:6px 8px} .picker{left:0; right:0; transform:none; margin:0 8px; bottom:84px; border-radius:16px; padding:12px} .picker button{padding:10px 12px; font-size:16px; border-radius:10px} }
  @media (max-width: 600px){ h1{font-size:22px} .sub{font-size:14px} .controls{flex-direction:column; align-items:stretch} .controls label{display:flex; justify-content:space-between; align-items:center} .pile h3,.section h3{font-size:13px} .playerHeader{flex-direction:column; align-items:flex-start; gap:4px} .card{width:64px; height:92px; font-size:22px} .card.small{width:48px; height:72px; font-size:18px} .stack{gap:10px} #aiTop .playerArea{padding:8px} .scorebar{gap:8px} .scores{font-size:12px} .picker{bottom:92px} }
  *{ -webkit-tap-highlight-color: rgba(0,0,0,0) }
  button, .card.playable{ touch-action: manipulation }
  /* Mini pile */
  #miniPile{ position: fixed; right: 10px; top: 10px; z-index: 50; display:none; width: 170px; max-height: 50vh; overflow:auto; background: rgba(0,0,0,.28); border:1px solid rgba(255,255,255,.18); border-radius:14px; padding:8px; backdrop-filter: blur(6px); box-shadow:0 6px 24px rgba(0,0,0,.35) }
  #miniPile h4{ margin:0 0 4px 0; font-size:12px; opacity:.9 }
  #miniInfo{ font-size:12px; opacity:.9; margin-bottom:6px }
  #miniMore{ font-size:11px; opacity:.9; margin-top:4px; text-align:right }
  #miniStack .card{ transform: scale(.9) }
  .miniAnchor{ position:fixed; width:36px; height:36px; border-radius:18px; background: rgba(0,0,0,.38); border:1px solid rgba(255,255,255,.22); color:#fff; display:none; align-items:center; justify-content:center; z-index:49; font-size:14px; }
  @media (min-width:901px){ #miniPile,.miniAnchor{ display:none !important } }
  /* Settings modal */
  #settingsBtn{ margin-left:auto }
  .modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:1200; }
  .modal .backdrop{ position:absolute; inset:0; background: rgba(0,0,0,.5); }
  .modal .content{ position:relative; background:#113f2d; border:1px solid #1d5e45; border-radius:14px; padding:14px; max-width: 560px; width: 92vw; color:var(--ivory); box-shadow:0 10px 40px rgba(0,0,0,.45) }
  .modal h3{ margin:0 0 8px 0 }
  .modal .row{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin:8px 0 }
  .modal .actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:10px }
  /* Round summary modal */
  #roundModal .content{ max-width:720px }
  .accordion .item{ border-top:1px solid rgba(255,255,255,.12); padding:8px 0 }
  .accordion .item h4{ margin:0; display:flex; align-items:center; justify-content:space-between; gap:8px; cursor:pointer }
  .badgeChip{ background: rgba(255,255,255,.14); border:1px solid rgba(255,255,255,.22); padding:2px 6px; border-radius:999px; font-size:11px }
</style>
</head>
<body>
  <div class="table">
    <h1>Tens</h1>
    <p class="sub">Goal: shed all cards in hand and on the table (face-up then face-down). Clearing happens on any <b>10</b> or when the current value count reaches <b>4+</b>. Higher-than-last forces a pickup first. After a clear, <b>the same player continues</b>.</p>

    <div class="controls">
      <label>Players
        <select id="playerCount">
          <option value="2">2 (you + 1 AI)</option>
          <option value="3" selected>3 (you + 2 AI)</option>
          <option value="4">4 (you + 3 AI)</option>
          <option value="5">5 (you + 4 AI)</option>
          <option value="6">6 (you + 5 AI)</option>
        </select>
      </label>
      <label>AI Difficulty
        <select id="aiDifficulty">
          <option value="easy" selected>Easy</option>
          <option value="medium">Medium</option>
          <option value="hard">Hard</option>
          <option value="expert">Expert</option>
          <option value="adaptive">Adaptive (per round)</option>
          <option value="lose">Tries to lose ðŸ¤¡</option>
        </select>
      </label>
      <button id="newRound" class="primary">Start New Game</button>
      <button id="newGame">Forfeit Game</button>
      <button id="runTests" style="display:none">Run Rule Tests</button>
      <button id="settingsBtn">Settings</button>
      <span class="hint">Match ends when someone hits 150+ points.</span>
    </div>

    <div class="board">
      <div class="lane"><div class="playerArea panel" id="aiTop"></div></div>
      <div>
        <div class="pile" id="centerPile">
          <h3>Center Pile</h3>
          <div id="pileInfo" class="hint">â€”</div>
          <div class="stack" id="pileStack"></div>
        </div>
        <div class="panel" id="logWrap" style="margin-top:10px">
          <h3 style="display:flex;align-items:center;gap:10px">
            Log
            <label style="margin-left:auto;display:flex;align-items:center;gap:6px;font-weight:500;font-size:12px;opacity:.9">Show snapshots <input type="checkbox" id="logSnapshots"></label>
          </h3>
          <div class="log" id="log"></div>
        </div>
      </div>
      <div class="lane"><div class="playerArea panel me" id="human"></div></div>
    </div>
  </div>

  <div class="scorebar collapsed" id="scorebar">
    <button id="scoreToggle" title="Toggle status">Status â–¾</button>
    <div class="scores" id="scores"></div>
    <div style="margin-left:auto" id="status"></div>
  </div>

  <div class="toast" id="toast"></div>
  <div class="picker" id="picker"></div>

  <div id="miniPile"><h4>Pile</h4><div id="miniInfo">â€”</div><div class="stack" id="miniStack"></div><div id="miniMore"></div></div>
  <div class="miniAnchor" id="miniAnchor">â—»ï¸Ž</div>

  <!-- Settings modal -->
  <div class="modal" id="settingsModal">
    <div class="backdrop"></div>
    <div class="content">
      <h3>Settings</h3>
      <div class="row"><span>Pause before board clear</span><input type="checkbox" id="setPauseBefore"></div>
      <div class="row"><span>Warn when an <b>AI</b> player has â‰¤ <input id="setWarnThresh" type="number" min="1" max="30" value="5" style="width:60px"> cards</span><input type="checkbox" id="setWarnOn"></div>
      <div class="row"><span>Show suits</span><input type="checkbox" id="setSuits"></div>
      <div class="row"><span>Tap mini pile to hide/show</span><input type="checkbox" id="setMiniTap"></div>
      <div class="actions"><button id="setCancel">Cancel</button><button class="primary" id="setSave">Save</button></div>
    </div>
  </div>

  <!-- Round summary modal -->
  <div class="modal" id="roundModal">
    <div class="backdrop"></div>
    <div class="content">
      <h3 id="roundTitle">Round complete!</h3>
      <div id="roundBody"></div>
      <div class="actions"><button class="primary" id="roundOk">Start Next Round</button></div>
    </div>
  </div>

<script>
// ===== Utility =====
const SUITS=["â™ ","â™¥","â™¦","â™£"]; const RANKS=["A","2","3","4","5","6","7","8","9","10","J","Q","K"]; const RVAL=Object.fromEntries(RANKS.map((r,i)=>[r,i+1]));
const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
function scoringValue(rank){ if(rank==='10')return 30; if(['J','Q','K'].includes(rank))return 10; if(rank==='A')return 1; return Number(rank); }
function decksForPlayers(p){ if(p===2)return 1; if(p<=5)return 2; if(p<=8)return 3; if(p<=10)return 4; if(p<=13)return 5; return 6; }
function makeDeck(n){ const d=[]; for(let k=0;k<n;k++){ for(const s of SUITS){ for(const r of RANKS){ d.push({r,s}); } } } return shuffle(d); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

// ===== Names for AI =====
const MALE_NAMES=["Greg","Paul","Alex","Jordan","Chris","Logan","Dylan","Corey","Brett","Terry"]; 
const FEMALE_NAMES=["Mary","Alicia","Ashley","Veronica","Kelly","Dana","Leslie","Sasha","Quinn","Avery"]; 
const AI_NAMES=[...MALE_NAMES,...FEMALE_NAMES];

// ===== Settings (with persistence) =====
const settings={ pauseBefore:false, warnOn:false, warnThresh:5, showSuits:false, miniTap:false, miniCorner:'tr', miniHidden:false };
function loadSettings(){ try{ const s=JSON.parse(localStorage.getItem('tens_settings')||'null'); if(s){ Object.assign(settings,s); } }catch{} }
function saveSettings(){ try{ localStorage.setItem('tens_settings',JSON.stringify(settings)); }catch{} }

// ===== State =====
const state={ players:[], pile:[], currentValue:null, currentCount:0, turn:0, roundActive:false, dealer:-1, matchActive:true, mustDeclare:new Set(), warnedAt:new Map(), roundStats:null, aiAdaptive:'medium' };
function freshPlayers(n){
  const needAI=Math.max(0,n-1);
  const pool=shuffle([...AI_NAMES]);
  const chosen=[]; for(let i=0;i<needAI;i++){ chosen.push(pool[i % pool.length]); }
  state.players=Array.from({length:n},(_,i)=>({id:i,name: i===0 ? 'You' : `${chosen[i-1]} (AI)`, isHuman:i===0, hand:[], slots:[], score:0}));
}
function nextDealer(){ state.dealer=(state.dealer+1)%state.players.length; }
function resetMatch(){ state.players.forEach(p=>p.score=0); state.dealer=-1; state.matchActive=true; logClear(); updateScores(); state.warnedAt.clear(); }

// ===== Deal (ensure 11 hand + 4 up/4 down) =====
function ensureDeckSizeFor(nPlayers){ const needEach=11+8; const needTotal=nPlayers*needEach; let decks=decksForPlayers(nPlayers); let deck=makeDeck(decks); while(deck.length<needTotal){ decks+=1; deck=makeDeck(decks); } return deck; }
function dealRound(){ const d=ensureDeckSizeFor(state.players.length); for(const p of state.players){ p.hand=[]; p.slots=[]; }
  for(const p of state.players){ for(let i=0;i<4;i++){ const down=d.pop(); const up=d.pop(); p.slots.push({down,up}); } }
  for(const p of state.players){ for(let i=0;i<11;i++){ p.hand.push(d.pop()); } }
  state.pile=[]; state.currentValue=null; state.currentCount=0; state.roundActive=true; state.mustDeclare.clear(); state.warnedAt.clear(); state.turn=(state.dealer+1)%state.players.length; state.roundStats={ pickups:new Map() };
}

// ===== Helpers =====
function faceUpCards(p){ const arr=[]; p.slots.forEach((s,idx)=>{ if(s && s.up){ arr.push({...s.up,_slot:idx}); } }); return arr; }
function faceDownCount(p){ return p.slots.filter(s=>!!(s&&s.down)).length; }
function removeFaceUpOfRank(p,rank,count){ const removed=[]; for(const s of p.slots){ if(count && s && s.up && s.up.r===rank){ removed.push(s.up); s.up=null; count--; if(count===0) break; } } return removed; }
function countFaceUpRank(p,rank){ let n=0; for(const s of p.slots){ if(s && s.up && s.up.r===rank) n++; } return n; }
function countHandRank(p,rank){ return p.hand.filter(c=>c && c.r===rank).length; }

// ===== Render =====
function makeCardEl(card,small=false,hidden=false){ const d=document.createElement('div'); const rr=card?.r??''; const ss=card?.s??'â™ '; d.className='card'+(small?' small':'')+(hidden?' faceDown':''); if(!hidden){ d.textContent=rr; if(ss==='â™¥'||ss==='â™¦') d.classList.add('red'); } return d; }
function groupByRank(cards){ const m={}; for(const c of cards){ if(!c||!c.r) continue; (m[c.r]??=[]).push(c); } return m; }
function canPlayRank(rank){ if(rank==='10') return true; if(state.currentValue===null) return true; return RVAL[rank] <= state.currentValue; }

function render(){ const aiWrap=document.getElementById('aiTop'), meWrap=document.getElementById('human'); aiWrap.innerHTML=''; meWrap.innerHTML='';
  state.players.forEach((p,idx)=>{ const area=document.createElement('div'); area.className='playerArea'+(p.isHuman?' me':''); if(idx===state.turn && state.roundActive) area.classList.add('turnGlow');
    const hdr=document.createElement('div'); hdr.className='playerHeader'; const left=document.createElement('div'); left.innerHTML=`<b>${p.name}</b> <span class="badge">hand: ${p.hand.filter(Boolean).length}</span>`; const right=document.createElement('div'); right.innerHTML=`<span class="badge">table: ${faceUpCards(p).length + faceDownCount(p)}</span>`; hdr.append(left,right); area.append(hdr);
    const slotRow=document.createElement('div'); slotRow.style.display='grid'; slotRow.style.gridTemplateColumns='repeat(4, 56px)'; slotRow.style.gap='8px';
    p.slots.forEach((s,slotIdx)=>{ const col=document.createElement('div'); col.style.height='68px'; col.style.position='relative';
      if(s?.down){ const downEl=makeCardEl({r:'',s:'â™ '},!p.isHuman,true); downEl.style.position='absolute'; downEl.style.top='6px'; downEl.style.left='0'; downEl.style.transform='scale(0.98)'; if(p.isHuman && state.turn===p.id && state.roundActive && !s.up){ downEl.classList.add('playable'); downEl.title='Flip this face-down card'; downEl.onclick=()=>tryFlipFaceDownSlot(slotIdx); } col.append(downEl); }
      if(s?.up){ const upEl=makeCardEl(s.up,!p.isHuman,false); upEl.style.position='absolute'; upEl.style.top='0'; upEl.style.left='0'; upEl.style.zIndex='2'; if(p.isHuman && state.turn===p.id && state.roundActive){ const qtyFU=countFaceUpRank(p,s.up.r); upEl.classList.add('playable'); upEl.onclick=()=>promptCountAndPlay(s.up.r,'faceUp',qtyFU); } col.append(upEl); }
      if(!s?.up && !s?.down){ const empty=document.createElement('div'); empty.style.height='68px'; col.append(empty); }
      slotRow.append(col); });
    const fuSec=document.createElement('div'); fuSec.className='section'; fuSec.innerHTML='<h3>Table (4 up over 4 down)</h3>'; area.append(fuSec); area.append(slotRow);
    if(p.isHuman){ const handSec=document.createElement('div'); handSec.className='section'; handSec.innerHTML='<h3>Your Hand</h3>'; const handRow=document.createElement('div'); handRow.className='stack'; const groups=groupByRank(p.hand); Object.keys(groups).sort((a,b)=>RVAL[a]-RVAL[b]).forEach(r=>{ const qty=groups[r].length; const wrap=document.createElement('div'); wrap.style.display='flex'; wrap.style.gap='4px'; groups[r].forEach(()=>{ const el=makeCardEl({r,s:'â™ '},false,false); if(canPlayRank(r)) el.classList.add('playable'); el.onclick=()=>promptCountAndPlay(r,'hand',qty); wrap.append(el); }); handRow.append(wrap); }); area.append(handSec); area.append(handRow); }
    (p.isHuman?meWrap:aiWrap).append(area); });
  const pileStack=document.getElementById('pileStack'); pileStack.innerHTML=''; state.pile.filter(Boolean).forEach((c)=>{ const el=makeCardEl(c,true,false); el.style.opacity=1; pileStack.append(el); });
  document.getElementById('pileInfo').textContent= state.currentValue? `${RANKS[state.currentValue-1]} Ã— ${state.currentCount}` : 'Fresh start';
  updateScores(); renderMiniPile(); }

// ===== Logging & UI Helpers =====
function log(msg){ const el=document.getElementById('log'); const p=document.createElement('div'); p.textContent=msg; el.append(p); el.scrollTop=el.scrollHeight; }
function labelActive(cv=state.currentValue,cc=state.currentCount){ return cv? `${RANKS[cv-1]} Ã— ${cc}` : 'Fresh start'; }
function logAction(msg,opts={}){ const el=document.getElementById('log'); const row=document.createElement('div'); const text=document.createElement('div'); text.textContent=msg; row.append(text); const showSnap=document.getElementById('logSnapshots')?.checked; if(showSnap){ const snap=document.createElement('div'); snap.className='stack'; const cards=(opts.snapshotCards||[]).filter(Boolean); cards.forEach(c=>snap.append(makeCardEl(c,true,false))); if(cards.length) row.append(snap); } el.append(row); el.scrollTop=el.scrollHeight; }
function logBoardState(){ const label=state.currentValue? `${RANKS[state.currentValue-1]} Ã— ${state.currentCount}` : 'Fresh start'; log(`Board â†’ ${label} (cards: ${state.pile.length})`); }
function logClear(){ document.getElementById('log').innerHTML=''; }
function toast(msg){ const t=document.getElementById('toast'); t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1600); }
function enableHumanChoices(){ render(); }
function isPauseOn(){ return !!settings.pauseBefore; }
async function showPauseModal(cards,title){ return new Promise(resolve=>{ const pk=document.getElementById('picker'); pk.innerHTML=''; const h=document.createElement('div'); h.className='row'; const b=document.createElement('b'); b.textContent=title; h.append(b); pk.append(h); const stack=document.createElement('div'); stack.className='stack'; (cards||[]).filter(Boolean).forEach(c=>stack.append(makeCardEl(c,true,false))); pk.append(stack); const btn=document.createElement('button'); btn.textContent='Continue'; btn.onclick=()=>{ pk.style.display='none'; resolve(); }; pk.append(btn); pk.style.display='flex'; }); }
async function maybePauseBefore(kind,cards,actorName){ if(!isPauseOn()) return; const who=actorName?`${actorName} is `:''; const title= kind==='clear' ? `${who}about to clear the pile` : `${who}about to pick up the pile`; await showPauseModal(cards,title); }
async function showRevealModal(card){ return new Promise(resolve=>{ const pk=document.getElementById('picker'); pk.innerHTML=''; const h=document.createElement('div'); h.className='row'; const b=document.createElement('b'); b.textContent=`You flipped ${card?.r??''}`; h.append(b); pk.append(h); const stack=document.createElement('div'); stack.className='stack'; stack.append(makeCardEl(card,true,false)); pk.append(stack); const btn=document.createElement('button'); btn.textContent='OK'; btn.onclick=()=>{ pk.style.display='none'; resolve(); }; pk.append(btn); pk.style.display='flex'; }); }
async function showRevealChoicePicker(rank, fuQty, hQty){ return new Promise(resolve=>{ const pk=document.getElementById('picker'); pk.innerHTML=''; const title=document.createElement('div'); title.className='row'; const b=document.createElement('b'); b.textContent=`Play ${rank}? Choose extras:`; title.append(b); pk.append(title);
  let includeFU = fuQty>0; let includeHand = hQty>0; let max = 1 + (includeFU?fuQty:0) + (includeHand?hQty:0);
  const toggles=document.createElement('div'); toggles.className='row';
  if(fuQty>0){ const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=true; const lb=document.createElement('label'); lb.textContent=`Include face-up (${fuQty})`; cb.onchange=()=>{ includeFU=cb.checked; rebuildCounts(); }; toggles.append(cb,lb); }
  if(hQty>0){ const cbh=document.createElement('input'); cbh.type='checkbox'; cbh.checked=true; const lbh=document.createElement('label'); lbh.textContent=`Include hand (${hQty})`; cbh.onchange=()=>{ includeHand=cbh.checked; rebuildCounts(); }; toggles.append(cbh,lbh); }
  pk.append(toggles);
  const countRow=document.createElement('div'); countRow.className='row'; const choices=document.createElement('div'); choices.className='choices'; countRow.append(choices); pk.append(countRow);
  function rebuildCounts(){ max = 1 + (includeFU?fuQty:0) + (includeHand?hQty:0); renderButtons(); }
  function renderButtons(){ choices.innerHTML=''; for(let i=1;i<=max;i++){ const bt=document.createElement('button'); bt.textContent=String(i); bt.onclick=()=>{ pk.style.display='none'; resolve({useFU:includeFU, useHand:includeHand, count:i}); }; choices.append(bt); } }
  renderButtons();
  const cancel=document.createElement('button'); cancel.textContent='Cancel'; cancel.onclick=()=>{ pk.style.display='none'; resolve(null); }; pk.append(cancel);
  pk.style.display='flex'; }); }

// ===== Human interactions (picker) =====
function promptCountAndPlay(rank, source, max){
  if(!state.roundActive) return;
  const current = state.players[state.turn];
  if(!current?.isHuman) return;
  if(source==='faceUp' && countFaceUpRank(current, rank)===0) return;
  if(rank==='10'){ // Special-case 10: always play exactly one
    playCards(current, rank, source, 1, false, false);
    return;
  }
  const fuQty = countFaceUpRank(current, rank);
  const hQty  = countHandRank(current, rank);
  if(max===1){
    const extrasElsewhere = (source==='hand') ? (fuQty>0) : (hQty>0);
    if(!extrasElsewhere){ playCards(current, rank, source, 1, false, false); return; }
  }
  showPicker(rank, source, max);
}

function showPicker(rank, source, max){
  const pk=document.getElementById('picker'); pk.innerHTML=''; const p = state.players[state.turn];
  const title=document.createElement('div'); title.className='row'; const b=document.createElement('b'); b.textContent=`Play ${rank} â€” choose count:`; title.append(b); pk.append(title);
  let includeFU=false, includeHand=false; let countCap=max; let capNote=null; let buttons=null;
  if(source==='hand'){ const fuQty=countFaceUpRank(p, rank); if(fuQty>0){ includeFU=true; countCap=max+fuQty; const row=document.createElement('div'); row.className='row'; const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=true; cb.id='incfu'; const lb=document.createElement('label'); lb.setAttribute('for','incfu'); lb.textContent=`Include face-up (${fuQty} available)`; cb.onchange=()=>{ includeFU=cb.checked; countCap = includeFU ? (max + fuQty) : max; if(capNote) capNote.textContent=`Max: ${countCap}`; rebuildButtons(); }; row.append(cb, lb); pk.append(row); capNote=document.createElement('span'); capNote.style.opacity='.8'; capNote.style.margin='0 8px'; capNote.textContent=`Max: ${countCap}`; pk.append(capNote); } }
  else if(source==='faceUp'){ const hQty=countHandRank(p, rank); if(hQty>0){ includeHand=true; countCap=max+hQty; const row=document.createElement('div'); row.className='row'; const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=true; cb.id='inchand'; const lb=document.createElement('label'); lb.setAttribute('for','inchand'); lb.textContent=`Include hand (${hQty} available)`; cb.onchange=()=>{ includeHand=cb.checked; countCap = includeHand ? (max + hQty) : max; if(capNote) capNote.textContent=`Max: ${countCap}`; rebuildButtons(); }; row.append(cb, lb); pk.append(row); capNote=document.createElement('span'); capNote.style.opacity='.8'; capNote.style.margin='0 8px'; capNote.textContent=`Max: ${countCap}`; pk.append(capNote); } }
  function rebuildButtons(){ if(!buttons){ buttons=document.createElement('div'); buttons.className='row'; pk.append(buttons); } buttons.innerHTML=''; for(let i=1;i<=countCap;i++){ const btn=document.createElement('button'); btn.textContent=String(i); btn.onclick=()=>{ pk.style.display='none'; playCards(state.players[state.turn], rank, source, i, includeFU, includeHand); }; buttons.append(btn);} }
  rebuildButtons();
  const cancel=document.createElement('button'); cancel.textContent='Cancel'; cancel.onclick=()=> pk.style.display='none'; pk.append(cancel);
  pk.style.display='flex';
}

// ===== Play Logic =====
async function playCards(player,rank,source,count,includeFU=false,includeHand=false){ const isTen=(rank==='10'); const rv=RVAL[rank]; const prevLabel=labelActive();
  if(!isTen && state.currentValue!==null && rv>state.currentValue){
    const pileBefore=state.pile.slice(); const attempted=Array.from({length:count},()=>({r:rank,s:'â™ '}));
    logAction(`${player.name} overplays with ${rank}Ã—${count} (was ${prevLabel}); picks up.`,{snapshotCards:[...pileBefore,...attempted]});
    await maybePauseBefore('pickup',[...pileBefore,...attempted],player.name);
    if(state.pile.length){ player.hand.push(...state.pile.filter(Boolean)); }
    if(source==='faceUp'){ const moved=removeFaceUpOfRank(player,rank,count); if(moved.length) player.hand.push(...moved); }
    state.pile = [];
    state.currentValue=null; state.currentCount=0; incPickup(player); render(); await sleep(200); return player.isHuman? enableHumanChoices(): aiTakeTurn(player,true);
  }
  let played=[]; if(source==='hand'){ let moved=0; const rest=[]; for(const c of player.hand){ if(c && moved<count && c.r===rank){ played.push(c); moved++; } else rest.push(c); } player.hand=rest; if(includeFU && moved<count){ const need=count-moved; const extra=removeFaceUpOfRank(player,rank,need); played.push(...extra); } }
  else if(source==='faceUp'){ const removed=removeFaceUpOfRank(player,rank,count); played.push(...removed); if(includeHand && removed.length<count){ const need=count-removed.length; let moved=0; const rest=[]; for(const c of player.hand){ if(c && moved<need && c.r===rank){ played.push(c); moved++; } else rest.push(c); } player.hand=rest; } }
  else if(source==='faceDownReveal'){ /* handled elsewhere */ }
  if(isTen){ logAction(`${player.name} plays ${rank} from ${source}; was ${prevLabel} â†’ clear.`,{snapshotCards:[...state.pile.slice(),...played]}); }
  else { logAction(`${player.name} plays ${rank}Ã—${played.length} from ${source}${includeFU?'+face-up':''}${includeHand?'+hand':''}; was ${prevLabel}.`,{snapshotCards:[...state.pile.slice(),...played]}); }
  state.pile.push(...played);
  if(isTen){ const snap=[...state.pile]; await maybePauseBefore('clear',snap,player.name); await clearPile(player,'10'); if(hasCards(player)) { await sleep(180); return player.isHuman? enableHumanChoices(): aiTakeTurn(player,true); } }
  else { if(state.currentValue===rv) state.currentCount+=played.length; else { state.currentValue=rv; state.currentCount=played.length; } if(state.currentCount>=4){ const snap=[...state.pile]; await maybePauseBefore('clear',snap,player.name); await clearPile(player,`${rank} reached ${state.currentCount}`); if(hasCards(player)) { await sleep(180); return player.isHuman? enableHumanChoices(): aiTakeTurn(player,true); } } }
  maybeDeclare(player); logBoardState(); endOrNext(); }

function maybeDeclare(p){ const remaining=p.hand.filter(Boolean).length + faceUpCards(p).length + faceDownCount(p); if(remaining===1 && !state.mustDeclare.has(p.id)){ state.mustDeclare.add(p.id); toast(`${p.name}: "One card!"`); log(`${p.name} declares: one card`); }
  // AI one-card modal (blocking)
  if(!p.isHuman && remaining===1){ showBlockingModal(`${p.name} has one card left.`); }
  // Warn threshold modal (AI only)
  if(settings.warnOn && !p.isHuman){ const key=p.id; const prev=(state.warnedAt.get(key)||Infinity); if(remaining<=settings.warnThresh && remaining>0 && remaining<prev){ showBlockingModal(`${p.name} has ${remaining} cards left.`); state.warnedAt.set(key,remaining); } if(remaining>settings.warnThresh){ state.warnedAt.delete(key); } }
}
function hasCards(p){ return p.hand.filter(Boolean).length + faceUpCards(p).length + faceDownCount(p) > 0; }

// ===== Modals =====
function modalBase(msg,blocking=true){ const pk=document.getElementById('picker'); pk.innerHTML=''; const row=document.createElement('div'); row.className='row'; const b=document.createElement('b'); b.textContent=msg; row.append(b); pk.append(row); const ok=document.createElement('button'); ok.textContent='OK'; ok.onclick=()=>{ pk.style.display='none'; }; pk.append(ok); pk.style.display='flex'; if(!blocking){ setTimeout(()=>{ if(pk.style.display==='flex') pk.style.display='none'; },1400); } }
function showBlockingModal(msg){ modalBase(msg,true); }

// ===== Face-down flip =====
async function tryFlipFaceDownSlot(slotIdx){ const p=state.players[state.turn]; const s=p.slots[slotIdx]; if(!s||s.up||!s.down) return; const c=s.down; s.down=null; if(!c){ render(); return; } const rv=RVAL[c.r]; const prevLabel=labelActive(); if(p.isHuman){ await showRevealModal(c); }
  // Overplay on blind flip (non-10): pickup full pile + flipped card; same player continues
  if(state.currentValue!==null && rv>state.currentValue && c.r!=='10'){ const pileBefore=state.pile.slice(); const show=[...pileBefore,c]; logAction(`${p.name} flips ${c.r} over ${prevLabel}; picks up.`,{snapshotCards:show}); await maybePauseBefore('pickup',show,p.name); if(state.pile.length){ p.hand.push(...state.pile.filter(Boolean)); } state.pile = []; p.hand.push(c); state.currentValue=null; state.currentCount=0; incPickup(p); render(); logBoardState(); await sleep(80); return p.isHuman? enableHumanChoices(): aiTakeTurn(p,true); }
  // Normal flip path
  logAction(`${p.name} flips ${c.r}${p.isHuman?'':' (AI)'}; was ${prevLabel}.`,{snapshotCards:[...state.pile.slice(),c]}); state.pile.push(c);
  if(c.r==='10'){ const snap=[...state.pile]; await maybePauseBefore('clear',snap,p.name); await clearPile(p,'10 (blind)'); if(hasCards(p)) return enableHumanChoices(); }
  else {
    if(state.currentValue===null){ state.currentValue=rv; state.currentCount=1; }
    else if(rv===state.currentValue){ state.currentCount+=1; }
    else { state.currentValue=rv; state.currentCount=1; }

    if(p.isHuman){ const fuQty=countFaceUpRank(p,c.r); const hQty=countHandRank(p,c.r); if(fuQty>0 || hQty>0){ const choice=await showRevealChoicePicker(c.r,fuQty,hQty); if(choice){ let toAdd=choice.count-1; if(choice.useFU && fuQty>0){ const takeFU=Math.min(fuQty,toAdd); const extraFU=removeFaceUpOfRank(p,c.r,takeFU); state.pile.push(...extraFU); state.currentCount+=extraFU.length; toAdd-=extraFU.length; } if(choice.useHand && hQty>0 && toAdd>0){ let moved=0; const rest=[]; for(const x of p.hand){ if(x && moved<toAdd && x.r===c.r){ state.pile.push(x); moved++; } else rest.push(x); } p.hand=rest; state.currentCount+=moved; } } } }
    else { const canFU=removeFaceUpOfRank(p,c.r,99); if(canFU.length){ state.pile.push(...canFU); state.currentCount+=canFU.length; } let addH=[], rest=[]; for(const x of p.hand){ if(x && x.r===c.r) addH.push(x); else rest.push(x); } p.hand=rest; if(addH.length){ state.pile.push(...addH); state.currentCount+=addH.length; } }

    if(state.currentCount>=4){ const snap2=[...state.pile]; await maybePauseBefore('clear',snap2,p.name); await clearPile(p,`${c.r} reached ${state.currentCount}`); if(hasCards(p)) return enableHumanChoices(); }
  }
  maybeDeclare(p); logBoardState(); endOrNext(); }

// ===== Clear / Turn =====
async function clearPile(byPlayer,reason){ if(state.pile.length){ const pileBefore=[...state.pile]; logAction(`${byPlayer.name} clears the pile (${reason}).`,{snapshotCards:pileBefore}); state.pile.length=0; } state.currentValue=null; state.currentCount=0; render(); logBoardState(); await sleep(200); }
function endOrNext(){ render(); const finisher=state.players.find(p=>!hasCards(p)); if(finisher){ scoreRound(finisher); return; } state.turn=(state.turn+1)%state.players.length; render(); const cur=state.players[state.turn]; if(!cur.isHuman) aiTakeTurn(cur); }

// ===== AI =====
function getSelectedDifficulty(){ const el=document.getElementById('aiDifficulty'); return el? (el.value||'easy') : 'easy'; }
function getAIDifficulty(){ const sel=getSelectedDifficulty(); if(sel==='adaptive') return state.aiAdaptive; return sel; }
function displayDiffLabel(){ const sel=getSelectedDifficulty(); return sel==='adaptive' ? `Adaptive (${state.aiAdaptive})` : sel; }
function rem(p){ return p.hand.filter(Boolean).length + faceUpCards(p).length + faceDownCount(p); }
function everyoneEarly(){ return state.players.every(pl=> faceUpCards(pl).length===4 && faceDownCount(pl)===4 && pl.hand.filter(Boolean).length>=4); }
function pileCounts(){ const m={}; for(const c of state.pile){ if(!c) continue; m[c.r]=(m[c.r]||0)+1; } return m; }
function totalByRanks(m,ranks){ let s=0; for(const r of ranks){ s+=m[r]||0; } return s; }
function aiLog(p,msg){ log(`${p.name} [${displayDiffLabel()}]: ${msg}`); }
function pointsOf(cards){ return cards.reduce((acc,c)=>acc+scoringValue(c.r),0); }
function maxUnloadGroupPoints(p){ // best single-rank unload excluding 10s & Aces
  const fu=faceUpCards(p), hand=p.hand; const groups={}; [...fu,...hand].forEach(c=>{ if(!c) return; if(c.r==='10'||c.r==='A') return; groups[c.r]=(groups[c.r]||[]); groups[c.r].push(c); });
  let best=0; Object.values(groups).forEach(g=>{ best=Math.max(best, pointsOf(g)); }); return best; }
function pilePointsAdjustedForGuaranteedClear(p){ const counts=pileCounts(); let pts=pointsOf(state.pile); for(const r in counts){ const have = countHandRank(p,r)+countFaceUpRank(p,r); if(r!=='A' && counts[r]+have>=4){ // would guarantee a clear; exclude those
      const rPts = counts[r]*scoringValue(r); pts -= rPts; }
  } return Math.max(0,pts); }
async function aiTakeTurn(p,chain=false){ if(!state.roundActive) { endOrNext(); return; } await sleep(chain?180:420); const fu=faceUpCards(p); const diff=getAIDifficulty(); const pileLen=state.pile.length;
  // Special overplay rules (Hard/Expert)
  if((diff==='hard'||diff==='expert') && state.currentValue!==null){
    const counts=pileCounts(); const distinct=Object.keys(counts).length; const onlyAces = distinct===1 && counts['A']>0; const single3 = distinct===1 && counts['3']===1; const few2s = distinct===1 && counts['2']>=1 && counts['2']<=3;
    if(onlyAces){ // always overplay to collect aces (prefer face-up overcard, else blind)
      const higherFU=fu.map(c=>c.r).filter((r,i,a)=>a.indexOf(r)===i && RVAL[r]>1); if(higherFU.length) return playCards(p,higherFU[0],'faceUp',1);
      const i=p.slots.findIndex(s=>s && !s.up && s.down); if(i>=0) return tryFlipFaceDownSlot(i);
      const higherH=[...new Set(p.hand.map(c=>c?.r))].filter(r=>r && RVAL[r]>1); if(higherH.length) return playCards(p,higherH[0],'hand',1);
    }
    if(single3 || few2s){ const higherFU=fu.map(c=>c.r).filter((r,i,a)=>a.indexOf(r)===i && RVAL[r]>state.currentValue); if(higherFU.length) return playCards(p,higherFU[0],'faceUp',1); const higherH=[...new Set(p.hand.map(c=>c?.r))].filter(r=>r && RVAL[r]>state.currentValue); if(higherH.length) return playCards(p,higherH[0],'hand',1); const j=p.slots.findIndex(s=>s && !s.up && s.down); if(j>=0) return tryFlipFaceDownSlot(j); }
    if(diff==='expert'){ // Overplay if unload > pile points (adjusted) and pile not too diverse
      if(distinct<3){ const pilePts = pilePointsAdjustedForGuaranteedClear(p); const unload = maxUnloadGroupPoints(p); if(unload>pilePts){
          const higherFU=fu.map(c=>c.r).filter((r,i,a)=>a.indexOf(r)===i && RVAL[r]>state.currentValue); if(higherFU.length) return playCards(p,higherFU[0],'faceUp',1); const higherH=[...new Set(p.hand.map(c=>c?.r))].filter(r=>r && RVAL[r]>state.currentValue); if(higherH.length) return playCards(p,higherH[0],'hand',1); const k=p.slots.findIndex(s=>s && !s.up && s.down); if(k>=0) return tryFlipFaceDownSlot(k); }
      }
    }
  }
  // Losing mode: try to gain cards
  if(diff==='lose'){
    if(state.currentValue!==null){ const higherFU=fu.map(c=>c.r).filter((r,i,a)=>a.indexOf(r)===i && RVAL[r]>state.currentValue); if(higherFU.length) return playCards(p,higherFU[0],'faceUp',1); const higherH=[...new Set(p.hand.map(c=>c?.r))].filter(r=>r && RVAL[r]>state.currentValue); if(higherH.length) return playCards(p,higherH[0],'hand',1); }
    const iLose=p.slots.findIndex(s=>s && !s.up && s.down); if(iLose>=0) return tryFlipFaceDownSlot(iLose);
    const fuAvail=fu.map(c=>c.r).filter((r,i,arr)=> arr.indexOf(r)===i && canPlayRank(r)); if(fuAvail.length){ fuAvail.sort((a,b)=>RVAL[a]-RVAL[b]); return playCards(p,fuAvail[0],'faceUp',1); }
    const ranks=[...new Set(p.hand.map(c=>c?.r))].filter(r=>r && canPlayRank(r)); if(ranks.length){ ranks.sort((a,b)=>RVAL[a]-RVAL[b]); return playCards(p,ranks[0],'hand',1); }
  }

  // Standard considerations
  const ranksAvail=new Set(); p.hand.forEach(c=>{ if(c?.r) ranksAvail.add(c.r); }); fu.forEach(c=>ranksAvail.add(c.r));
  let legal=[...ranksAvail].filter(r=>canPlayRank(r)); const nonAce=legal.filter(r=>r!=='A'); if(nonAce.length) legal=nonAce; // hold aces

  const oppClose= state.players.some(pl=> pl.id!==p.id && rem(pl) <= 6);
  const early=everyoneEarly();
  const canClearNow=(r)=>{ const qty=p.hand.filter(c=>c?.r===r).length + fu.filter(c=>c.r===r).length + (state.currentValue!==null && RANKS[state.currentValue-1]===r ? state.currentCount : 0); return qty>=4; };
  const considerClear=(r)=>{ if(diff==='hard'||diff==='expert'){ if(oppClose && !early){ const unloadPts = maxUnloadGroupPoints(p); if(unloadPts < 15) return false; } } return true; };

  for(const r of legal){ if(r==='10') continue; if(canClearNow(r) && considerClear(r)){ const cntFU=fu.filter(c=>c.r===r).length; if(cntFU) return playCards(p,r,'faceUp',cntFU); const cntH=p.hand.filter(c=>c?.r===r).length; if(cntH) return playCards(p,r,'hand',cntH); } }

  // 10 logic
  const hasTenHand=p.hand.some(c=>c?.r==='10'); const hasTenFU=fu.some(c=>c.r==='10');
  if(hasTenHand||hasTenFU){ let use10=false; if(diff==='easy') use10 = oppClose || pileLen>6 || Math.random()<0.6; else if(diff==='medium') use10 = oppClose || pileLen>=10 || early; else { // hard/expert
      const unloadPts = maxUnloadGroupPoints(p);
      use10 = (!state.currentValue || pileLen>=12 || early) && (oppClose ? unloadPts>=15 : true);
    }
    if(use10){ if(hasTenHand) return playCards(p,'10','hand',1); else return playCards(p,'10','faceUp',1); }
  }

  const legalFU=fu.map(c=>c.r).filter((r,i,arr)=> arr.indexOf(r)===i && canPlayRank(r) && r!=='A'); if(legalFU.length){ legalFU.sort((a,b)=>RVAL[b]-RVAL[a]); const r=legalFU[0]; const cnt=fu.filter(c=>c.r===r).length; return playCards(p,r,'faceUp',cnt); }
  legal.sort((a,b)=>RVAL[b]-RVAL[a]); for(const r of legal){ if(r==='A') continue; const cntH=p.hand.filter(c=>c?.r===r).length; if(cntH){ return playCards(p,r,'hand',cntH); } }
  if(ranksAvail.has('A') && canPlayRank('A')){ if(countFaceUpRank(p,'A')>0) return playCards(p,'A','faceUp',1); if(p.hand.some(c=>c?.r==='A')) return playCards(p,'A','hand',1); }
  if(state.currentValue!==null){ const higherFU=fu.map(c=>c.r).filter((r,i,a)=>a.indexOf(r)===i && RVAL[r]>state.currentValue); if(higherFU.length) return playCards(p,higherFU[0],'faceUp',1); const higherH=[...new Set(p.hand.map(c=>c?.r))].filter(r=>r && RVAL[r]>state.currentValue); if(higherH.length) return playCards(p,higherH[0],'hand',1); }
  const i=p.slots.findIndex(s=>s && !s.up && s.down); if(i>=0){ return tryFlipFaceDownSlot(i); }
  endOrNext(); }

// ===== Scoring / Rounds =====
async function scoreRound(finisher){ state.roundActive=false; const pts=state.players.map(p=>{ let s=0; p.hand.forEach(c=>{ if(!c) return; s+=scoringValue(c.r); }); faceUpCards(p).forEach(c=>s+=scoringValue(c.r)); p.slots.forEach(sl=>{ if(sl?.down) s+=scoringValue(sl.down.r); }); return s; });
  pts.forEach((s,i)=> state.players[i].score+=s);
  log(`Round ended. ${finisher.name} went out. Scoring applied.`);
  updateScores();

  // Show end-of-round modal with scores and badges
  await showEndOfRoundModal(finisher, pts);

  const over=state.players.find(p=>p.score>=150);
  if(over){ state.matchActive=false; const winner=[...state.players].sort((a,b)=>a.score-b.score)[0]; toast(`Match Over! Winner: ${winner.name} (${winner.score})`); document.getElementById('status').textContent=`Match Over â€” Winner: ${winner.name}`; const btn=document.getElementById('newRound'); btn.disabled=false; btn.title=''; render(); return; }

  // Adaptive (per round) step: adjust difficulty after each round if selected
  if(getSelectedDifficulty()==='adaptive'){
    const meScore = state.players[0].score; const minScore = Math.min(...state.players.map(p=>p.score));
    const ladder=['easy','medium','hard','expert']; let idx=ladder.indexOf(state.aiAdaptive); if(idx<0) idx=1;
    if(meScore===minScore && idx<ladder.length-1) idx++; else if(meScore>minScore && idx>0) idx--;
    state.aiAdaptive = ladder[idx];
    log(`AI difficulty (Adaptive) adjusted to: ${state.aiAdaptive}`);
  }

  nextDealer();
  dealRound();
  document.getElementById('status').textContent=`New round. ${state.players[state.turn].name} to play.`;
  log(`New round begins. Dealer: ${state.players[state.dealer].name}. ${state.players[state.turn].name} starts.`);
  render();
  if(!state.players[state.turn].isHuman) aiTakeTurn(state.players[state.turn]); }

function updateScores(){ const wrap=document.getElementById('scores'); wrap.innerHTML=''; state.players.forEach(p=>{ const d=document.createElement('div'); d.className='slot'; d.textContent=`${p.name}: ${p.score}`; wrap.append(d); }); }
function forfeitMatch(){ if(!state.roundActive && !state.matchActive) return; state.roundActive=false; state.matchActive=false; document.getElementById('status').textContent='You forfeited. Match ended.'; log('You forfeited. Match ended.'); const btn=document.getElementById('newRound'); btn.disabled=false; btn.title=''; render(); }

// End-of-round modal (all players; badges; expandable)
function showEndOfRoundModal(finisher, roundPoints){ return new Promise(resolve=>{
  const modal=document.getElementById('roundModal'); const body=document.getElementById('roundBody'); const title=document.getElementById('roundTitle'); const ok=document.getElementById('roundOk'); body.innerHTML='';
  const matchOver = state.players.some(p=>p.score>=150);
  title.textContent = matchOver ? `Match Over! ${([...state.players].sort((a,b)=>a.score-b.score)[0]).name} wins!` : `Round complete! ${finisher.name} went out!`;

  // badges (most/least pickups)
  let maxP=-1, minP=Infinity; state.players.forEach(p=>{ const v=(state.roundStats.pickups.get(p.id)||0); maxP=Math.max(maxP,v); minP=Math.min(minP,v); });

  const acc=document.createElement('div'); acc.className='accordion';
  state.players.forEach((p,idx)=>{
    const item=document.createElement('div'); item.className='item';
    const head=document.createElement('h4'); const pts=roundPoints[idx];
    const badges=document.createElement('span');
    const pc=(state.roundStats.pickups.get(p.id)||0);
    if(pc===maxP && maxP>0){ const ch=document.createElement('span'); ch.className='badgeChip'; ch.title='Picked up the pile the most times this round'; ch.textContent='I want that pile!'; badges.append(ch); }
    if(pc===minP){ const ch=document.createElement('span'); ch.className='badgeChip'; ch.style.marginLeft='6px'; ch.title='Picked up the pile the fewest times this round'; ch.textContent='Keep that pile away from me!'; badges.append(ch); }
    head.innerHTML = `${p.name} â€” <b>${pts} pts</b>`; head.append(badges); item.append(head);

    const bodyRow=document.createElement('div'); bodyRow.style.display='none';
    const sec=(label,cards)=>{ const wrap=document.createElement('div'); const h=document.createElement('div'); h.textContent=label; h.style.margin='6px 0'; wrap.append(h); const st=document.createElement('div'); st.className='stack'; cards.forEach(c=>st.append(makeCardEl(c,true,false))); wrap.append(st); bodyRow.append(wrap); };
    const hand=[...p.hand]; const fu=faceUpCards(p); const fd=p.slots.map(s=>s?.down).filter(Boolean);
    if(idx===0){ // human expands by default
      bodyRow.style.display='block';
    }
    sec('Hand',hand); sec('Face-up',fu); sec('Face-down',fd);

    head.addEventListener('click',()=>{ bodyRow.style.display = bodyRow.style.display==='none' ? 'block' : 'none'; });
    item.append(bodyRow);
    acc.append(item);
  });
  body.append(acc);
  ok.textContent = matchOver ? 'Start New Game' : 'Start Next Round';
  ok.onclick=()=>{ modal.style.display='none'; resolve(); };
  modal.style.display='flex';
  }); }

// ===== Floating mini pile =====
function placeMiniByCorner(corner){ const mini=document.getElementById('miniPile'); const anchor=document.getElementById('miniAnchor'); const pos={tl:[10,10], tr:[window.innerWidth-10-mini.offsetWidth,10], bl:[10,window.innerHeight-10-mini.offsetHeight], br:[window.innerWidth-10-mini.offsetWidth, window.innerHeight-10-mini.offsetHeight]}; const [x,y]=pos[corner]||pos.tr; mini.style.left=x+'px'; mini.style.top=y+'px'; mini.style.right='auto'; mini.style.bottom='auto'; // anchor
  const ax = corner.includes('l')? 10 : (window.innerWidth-46); const ay = corner.includes('t')? 10 : (window.innerHeight-46); anchor.style.left=ax+'px'; anchor.style.top=ay+'px'; }
function renderMiniPile(){ const mini=document.getElementById('miniPile'); const mInfo=document.getElementById('miniInfo'); const mMore=document.getElementById('miniMore'); const mStack=document.getElementById('miniStack'); mStack.innerHTML=''; state.pile.filter(Boolean).forEach(c=> mStack.append(makeCardEl(c,true,false)) ); mInfo.textContent= state.currentValue? `${RANKS[state.currentValue-1]} Ã— ${state.currentCount}` : 'Fresh start'; const overflow = mStack.scrollHeight > mini.clientHeight; mMore.textContent = overflow ? 'Scroll to see all' : ''; mini.scrollTop = mini.scrollHeight; placeMiniByCorner(settings.miniCorner||'tr'); const anchor=document.getElementById('miniAnchor'); if(settings.miniHidden){ mini.style.display='none'; anchor.style.display='flex'; }else{ anchor.style.display='none'; }
}
let miniObserverInitialized=false; function initMiniObserver(){ if(miniObserverInitialized) return; miniObserverInitialized=true; const target=document.getElementById('centerPile'); const mini=document.getElementById('miniPile'); const anchor=document.getElementById('miniAnchor'); if(!('IntersectionObserver' in window) || !target) return; const io=new IntersectionObserver((entries)=>{ const e=entries[0]; const mobile=window.innerWidth<=900; if(mobile && (!e.isIntersecting) && !settings.miniHidden) mini.style.display='block'; else mini.style.display='none'; anchor.style.display = (mobile && settings.miniHidden) ? 'flex' : 'none'; },{root:null,threshold:0.1}); io.observe(target);
  // Hold-to-hide gesture if enabled
  let pressTimer=null; const PRESS_MS=1500; function startPress(){ if(!settings.miniTap) return; if(pressTimer) clearTimeout(pressTimer); pressTimer=setTimeout(()=>{ settings.miniHidden=true; saveSettings(); renderMiniPile(); pressTimer=null; },PRESS_MS); }
  function cancelPress(){ if(pressTimer){ clearTimeout(pressTimer); pressTimer=null; } }
  mini.addEventListener('mousedown',startPress); mini.addEventListener('touchstart',startPress,{passive:true}); mini.addEventListener('mouseup',cancelPress); mini.addEventListener('mouseleave',cancelPress); mini.addEventListener('touchend',cancelPress);
  anchor.addEventListener('click',()=>{ settings.miniHidden=false; saveSettings(); const mini=document.getElementById('miniPile'); mini.style.display='block'; renderMiniPile(); });
  // Drag to move & snap
  let dragging=false, startX=0, startY=0, baseX=0, baseY=0; function onDown(e){ dragging=true; cancelPress(); const rect=mini.getBoundingClientRect(); baseX=rect.left; baseY=rect.top; startX=(e.touches?e.touches[0].clientX:e.clientX); startY=(e.touches?e.touches[0].clientY:e.clientY); e.preventDefault(); }
  function onMove(e){ if(!dragging) return; const x=(e.touches?e.touches[0].clientX:e.clientX); const y=(e.touches?e.touches[0].clientY:e.clientY); const nx=baseX+(x-startX); const ny=baseY+(y-startY); mini.style.left=nx+'px'; mini.style.top=ny+'px'; mini.style.right='auto'; mini.style.bottom='auto'; }
  function onUp(){ if(!dragging) return; dragging=false; const rect=mini.getBoundingClientRect(); const cx=rect.left + rect.width/2; const cy=rect.top + rect.height/2; const corner = (cy<window.innerHeight/2 ? 't' : 'b') + (cx<window.innerWidth/2 ? 'l':'r'); settings.miniCorner=corner; saveSettings(); placeMiniByCorner(corner); }
  mini.addEventListener('mousedown',onDown); mini.addEventListener('touchstart',onDown,{passive:false}); window.addEventListener('mousemove',onMove); window.addEventListener('touchmove',onMove,{passive:false}); window.addEventListener('mouseup',onUp); window.addEventListener('touchend',onUp);
}

function incPickup(p){ const m=state.roundStats?.pickups; if(!m) return; const prev=m.get(p.id)||0; m.set(p.id,prev+1); }

// ===== Controls & Tests =====
window.addEventListener('keydown',(e)=>{ if(e.key==='T' && e.shiftKey){ const b=document.getElementById('runTests'); if(b) b.classList.toggle('dev'); } });
function startNewRound(){ const n=parseInt(document.getElementById('playerCount').value,10); freshPlayers(n); // random first dealer for first round
  state.dealer=Math.floor(Math.random()*n); dealRound(); document.getElementById('status').textContent=`Round in progress. ${state.players[state.turn].name} to play.`; logClear(); log(`New game started. Dealer: ${state.players[state.dealer].name}. ${state.players[state.turn].name} starts.`); render(); const btn=document.getElementById('newRound'); btn.disabled=true; btn.title='Game in progress'; if(!state.players[state.turn].isHuman) aiTakeTurn(state.players[state.turn]); }
function assert(cond,msg){ if(!cond) throw new Error(msg||'Assertion failed'); }
function clone(r){ return {r,s:'â™ '}; }
async function runTests(){ logClear(); log('Running rule testsâ€¦'); const sel=parseInt(document.getElementById('playerCount').value,10);
  // Test 1: Ten clears & only one ten is used
  freshPlayers(2); state.dealer=0; dealRound(); state.pile=[clone('7'),clone('7')]; state.currentValue=RVAL['7']; state.currentCount=2; state.players[0].hand=[clone('10'),clone('10')]; state.players[0].slots=[]; state.roundActive=true; state.turn=0; const beforeTens=state.players[0].hand.length; await promptCountAndPlay('10','hand',2); assert(state.pile.length===0,'Ten clears'); assert(state.players[0].hand.length===beforeTens-1,'Playing 10 uses exactly one');
  // Test 2: Overplay pickup returns attempted card to hand and same player continues
  freshPlayers(2); state.dealer=0; dealRound(); state.pile=[clone('5'),clone('5')]; state.currentValue=RVAL['5']; state.currentCount=2; state.players[0].hand=[clone('9'),clone('3')]; state.players[0].slots=[]; state.roundActive=true; state.turn=0; const before=state.players[0].hand.length; await playCards(state.players[0],'9','hand',1); assert(state.pile.length===0,'Overplay moves pile to hand'); assert(state.players[0].hand.length===before+2,'Attempted over card remains in hand; pile added'); assert(state.turn===0,'Same player continues after pickup');
  // Test 3: Four-of-a-kind clears and same player continues
  freshPlayers(2); state.dealer=0; dealRound(); state.pile=[clone('6'),clone('6'),clone('6')]; state.currentValue=RVAL['6']; state.currentCount=3; state.players[0].hand=[clone('6')]; state.players[0].slots=[]; state.roundActive=true; state.turn=0; await playCards(state.players[0],'6','hand',1); assert(state.pile.length===0,'Four-of-a-kind clears'); assert(state.turn===0,'Same player continues after clear');
  // Test 4: Picker shows when single in hand but extra in face-up, and default include is checked
  freshPlayers(2); state.dealer=0; dealRound(); state.players[0].hand=[clone('4')]; state.players[0].slots=[{down:null,up:clone('4')},{down:null,up:null},{down:null,up:null},{down:null,up:null}]; state.pile=[]; state.currentValue=null; state.currentCount=0; state.roundActive=true; state.turn=0; const pk1=document.getElementById('picker'); await promptCountAndPlay('4','hand',1); assert(pk1.style.display==='flex','Picker shown for optional include'); const cb=pk1.querySelector('#incfu'); assert(cb && cb.checked,'Include face-up is checked by default'); const buttons=[...pk1.querySelectorAll('.row button')]; buttons[0].click(); await sleep(50); assert(state.pile.length===1,'Played exactly one after picker'); assert(state.currentValue===RVAL['4'],'Active value set to played rank');
  // Test 5: Rendering robust to undefined
  freshPlayers(2); state.dealer=0; dealRound(); state.players[0].hand=[undefined, clone('A')]; state.pile=[clone('2'), undefined, clone('3')]; try{ render(); assert(true,'Render robust'); }catch(e){ throw new Error('Render should handle undefined cards safely'); }
  // Test 6: AI blind flip no human modal
  freshPlayers(2); state.dealer=0; dealRound(); state.players[1].isHuman=false; state.turn=1; const sl={down:clone('K'),up:null}; state.players[1].slots=[sl,{down:null,up:null},{down:null,up:null},{down:null,up:null}]; const pk=document.getElementById('picker'); pk.style.display='none'; await tryFlipFaceDownSlot(0); assert(pk.style.display!=='flex','AI blind flip should not show modal');
  // Test 7: Start-of-round consistency 2..6
  for(let n=2;n<=6;n++){ freshPlayers(n); state.dealer=0; dealRound(); state.players.forEach(pl=>{ assert(pl.hand.length===11,'Each hand has 11'); assert(pl.slots.length===4,'Exactly 4 slots'); pl.slots.forEach(s=>{ assert(!!s.up && !!s.down,'Slot has up & down'); }); }); }
  // Test 8: Blind overplay picks up full pile including flipped card
  freshPlayers(2); state.dealer=0; dealRound(); state.pile=[clone('5')]; state.currentValue=RVAL['5']; state.currentCount=1; state.turn=0; state.players[0].slots=[{down:clone('9'),up:null},{down:null,up:null},{down:null,up:null},{down:null,up:null}]; const hBefore=state.players[0].hand.length; await tryFlipFaceDownSlot(0); assert(state.pile.length===0,'Pile cleared to hand on blind overplay'); assert(state.players[0].hand.length===hBefore+2,'Picked up previous pile + flipped card'); assert(state.turn===0,'Same player continues after pickup');
  // Test 9: AI names assigned
  freshPlayers(4); assert(state.players[1].name && state.players[1].name.endsWith(' (AI)'),'AI name #1 assigned'); assert(state.players[2].name && state.players[2].name.endsWith(' (AI)'),'AI name #2 assigned');
  // Test 10: Human blind flip has count buttons
  freshPlayers(2); state.dealer=0; dealRound(); state.players[0].slots=[{down:clone('9'),up:null},{down:null,up:null},{down:null,up:null},{down:null,up:null}]; state.players[0].hand=[clone('9'), clone('9')]; state.pile=[]; state.currentValue=null; state.currentCount=0; state.turn=0; await tryFlipFaceDownSlot(0); const pk2=document.getElementById('picker'); const btns=[...pk2.querySelectorAll('.choices button')]; assert(btns.length>=1,'Reveal choice shows count buttons');

  document.getElementById('playerCount').value=String(sel); resetAll(); toast('Tests passed.'); log('Tests passed.'); }
function resetAll(){ const n=parseInt(document.getElementById('playerCount').value,10); freshPlayers(n); state.dealer=-1; state.matchActive=true; logClear(); render(); }

// Settings modal wiring
function openSettings(){ const m=document.getElementById('settingsModal'); m.style.display='flex'; const p=document.getElementById('setPauseBefore'); const w=document.getElementById('setWarnOn'); const t=document.getElementById('setWarnThresh'); const s=document.getElementById('setSuits'); const mt=document.getElementById('setMiniTap'); p.checked=settings.pauseBefore; w.checked=settings.warnOn; t.value=String(settings.warnThresh); s.checked=settings.showSuits; mt.checked=settings.miniTap; }
function saveSettingsFromUI(){ const p=document.getElementById('setPauseBefore'); const w=document.getElementById('setWarnOn'); const t=document.getElementById('setWarnThresh'); const s=document.getElementById('setSuits'); const mt=document.getElementById('setMiniTap'); settings.pauseBefore=!!p.checked; settings.warnOn=!!w.checked; settings.warnThresh=Math.max(1,Math.min(30,parseInt(t.value||'5',10))); settings.showSuits=!!s.checked; settings.miniTap=!!mt.checked; saveSettings(); document.getElementById('settingsModal').style.display='none'; render(); }

// Init
loadSettings();
// restore AI difficulty
try{ const savedDiff=localStorage.getItem('tens_ai_diff'); if(savedDiff){ const el=document.getElementById('aiDifficulty'); if(el) el.value=savedDiff; } }catch{}
resetAll();
initMiniObserver();

// Events
  document.getElementById('playerCount').addEventListener('change',resetAll);
  document.getElementById('aiDifficulty').addEventListener('change',()=>{ const sel=document.getElementById('aiDifficulty').value; try{ localStorage.setItem('tens_ai_diff', sel); }catch{} log(`AI difficulty set to ${displayDiffLabel()}`); });
  document.getElementById('newRound').addEventListener('click',startNewRound);
  document.getElementById('newGame').addEventListener('click',()=>{ forfeitMatch(); });
  document.getElementById('runTests').addEventListener('click',()=>{ runTests(); });
  document.getElementById('settingsBtn').addEventListener('click',openSettings);
  document.getElementById('setSave').addEventListener('click',saveSettingsFromUI);
  document.getElementById('setCancel').addEventListener('click',()=>{ document.getElementById('settingsModal').style.display='none'; });
  document.querySelector('#settingsModal .backdrop').addEventListener('click',()=>{ document.getElementById('settingsModal').style.display='none'; });
  document.getElementById('scoreToggle').addEventListener('click',()=>{ const sb=document.getElementById('scorebar'); const c=sb.classList.toggle('collapsed'); document.getElementById('scoreToggle').textContent = c? 'Status â–¾' : 'Status â–´'; });
</script>
</body>
</html>
